# Simple Event Router

## Overview

The aim of this example is to demonstrate how the `sls-testing-toolkit` can be used to test the following construct.

![Diagram showing the Simple Event Router construct](https://raw.githubusercontent.com/andybalham/sls-testing-toolkit/main/examples/simple-event-router/images/SimpleEventRouter.jpg)

The [`SimpleEventRouterConstruct`](https://github.com/andybalham/sls-testing-toolkit/blob/main/examples/simple-event-router/SimpleEventRouterConstruct.ts) consists of a single Lambda function that subscribes to an external SNS topic. The Lambda function then routes all received messages to one of two SNS topics depending on the content of the message. The internal algorithm of the Lambda function can be unit tested locally, but the challenge is how to test that the Lambda function works in conjunction with the topics. The only way to do this is to deploy to the cloud and test.

The Serverless Testing Toolkit helps here, as it allows you to deploy the construct under test as part of a test stack and test the construct in isolation. The result is the [`SimpleEventRouterTestStack`](https://github.com/andybalham/sls-testing-toolkit/blob/main/examples/simple-event-router/SimpleEventRouterTestStack.ts), which is shown below.

![Diagram showing the Simple Event Router test stack](https://raw.githubusercontent.com/andybalham/sls-testing-toolkit/main/examples/simple-event-router/images/SimpleEventRouterTestStack.jpg)

With the stack deployed, unit tests can be created that publish messages and observe the results and the functionality verified.

## `SimpleEventRouterConstruct`

This is a plain CDK construct. It doesn't have any dependency on `sls-testing-toolkit`.

## `SimpleEventRouterTestStack`

The test stack sub-classes the `IntegrationTestStack` from the `sls-testing-toolkit` and declares the following constants. These are used to tag the test resources that the unit tests will need to interact with.

```TypeScript
static readonly ResourceTagKey = 'SimpleEventRouterTestStack';

static readonly TestInputTopicId = 'TestInputTopic';

static readonly PositiveOutputTopicSubscriberId = 'PositiveOutputTopicSubscriberFunction';

static readonly NegativeOutputTopicSubscriberId = 'NegativeOutputTopicSubscriberFunction';
```

In the constructor the first thing is to call the `super` constructor.

```TypeScript
super(scope, id, {
  testResourceTagKey: SimpleEventRouterTestStack.ResourceTagKey,
  testFunctionIds: [
    SimpleEventRouterTestStack.PositiveOutputTopicSubscriberId,
    SimpleEventRouterTestStack.NegativeOutputTopicSubscriberId,
  ],
});
```

The value specified `testResourceTagKey` is used for the key when tagging the test resources. It should be unique to the stack, to avoid clashes with other tests.

For each value in `testFunctionIds`, `IntegrationTestStack` will create a Lambda function that will record all received events in a DynamoDB table.

Next is a test input topic to publish events to, to drive the functionality of the construct.

```TypeScript
const testInputTopic = new sns.Topic(this, SimpleEventRouterTestStack.TestInputTopicId);

this.addTestResourceTag(testInputTopic, SimpleEventRouterTestStack.TestInputTopicId);
```

The call to `addTestResourceTag` tags the topic using the `testResourceTagKey` value. This is required so that the topic can be located by the unit tests.

Next is the system under test, the `SimpleEventRouterConstruct`. An instance is created and the test topic passed in via the `props`.

```TypeScript
const sut = new SimpleEventRouterConstruct(this, 'SUT', {
  inputTopic: testInputTopic,
});
```

Finally, the observer functions are added as event subscribers to the SNS topics generated by the `SimpleEventRouterConstruct`.

```TypeScript
this.addEventSubscriber(
  sut.positiveOutputTopic,
  SimpleEventRouterTestStack.PositiveOutputTopicSubscriberId
);

this.addEventSubscriber(
  sut.negativeOutputTopic,
  SimpleEventRouterTestStack.NegativeOutputTopicSubscriberId
);
```

The stack can be deployed using the script `npm run simple-event-router-deploy`.

## Unit Tests

For the unit tests we will be using the [Mocha](https://mochajs.org/) testing framework and the [Chai](https://www.chaijs.com/guide) assertion library. The approach doesn't use anything specific to these, so it should be still viable if other frameworks and libraries are used.

Note, the `sls-testing-toolkit` requires that there is a `.env` file with an entry for `AWS_REGION`, e.g.:

```
AWS_REGION=eu-west-2
```

The unit tests interact with the deployed resources via a `IntegrationTestClient` instance. This is instantiated with the `testResourceTagKey` and initialised with a call to `initialiseClientAsync`. Once initialised, a call to `getSNSTestClient` returns a client that can be used to publish events to the topic.

```TypeScript
const testClient = new IntegrationTestClient({
  testResourceTagKey: SimpleEventRouterTestStack.ResourceTagKey,
});

let testInputTopic: SNSTestClient;

before(async () => {
  await testClient.initialiseClientAsync();
  testInputTopic = testClient.getSNSTestClient(SimpleEventRouterTestStack.TestInputTopicId);
});

beforeEach(async () => {
  await testClient.initialiseTestAsync();
});
```

The unit test itself is shown in full below. The key part being the call to `pollTestAsync`, which will poll at the interval specified until it times out or `until` returns `true`. The `until` function is passed the currently recorded observations. When this method completes, these observations are then filtered to verify that the event was routed as expected.

```TypeScript
  it(`Routes positive sums`, async () => {
    // Arrange

    const testEvent: Event = {
      values: [1, 2, 3],
    };

    // Act

    await testInputTopic.publishEventAsync(testEvent);

    // Await

    const { observations, timedOut } = await testClient.pollTestAsync({
      until: async (o) => o.length > 0,
      intervalSeconds: 2,
      timeoutSeconds: 12,
    });

    // Assert

    expect(timedOut, 'timedOut').to.be.false;

    const positiveObservations = TestObservation.filterById(
      observations,
      SimpleEventRouterTestStack.PositiveOutputTopicSubscriberId
    );

    const negativeObservations = TestObservation.filterById(
      observations,
      SimpleEventRouterTestStack.NegativeOutputTopicSubscriberId
    );

    expect(positiveObservations.length).to.be.greaterThan(0);
    expect(negativeObservations.length).to.equal(0);

    const routedEvent = JSON.parse(
      (positiveObservations[0].event as SNSEvent).Records[0].Sns.Message
    );
    expect(routedEvent).to.deep.equal(testEvent);
  });
```
